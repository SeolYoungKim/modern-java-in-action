# 포크/조인 프레임워크
- 병렬화 할 수 있는 작업을 재귀적으로 작은 작업으로 분할 후, 서브 태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계 됨
- 서브태스크를 `ForkJoinPool`의 작업자 스레드에 분산 할당하는 `ExecutorService` 인터페이스를 구현함


## RecursiveTask
- 스레드 풀을 이용하기 위해서는 `RecursiveTask<R>`의 서브 클래스를 만들어야 함.
  - `R`은 병렬화된 태스크가 생성하는 결과 형식이다.
  - 결과가 없을 때는 `RecursiveAction`형식이다. (결과가 없더라도, 다른 비지역 구조를 바꿀 수 있다.)
```java
public abstract class RecursiveTask<V> extends ForkJoinTask<V> {
    protected abstract V compute();
    // 이하 생략
}
```
- `compute()`를 구현하여 정의한다.
  - 해당 메서드는 태스크를 서브태스크로 분할하는 로직과, 더이상 분할할 수 없을 때 개별 서브태스크의 결과를 생산할 알고리즘을 정의한다.
```java
// compute 슈도 코드
if (태스크가 충분히 작거나 더이상 분할할 수 없다면) {
    순차적으로 태스크를 계산함;    
} else {
    태스크를 두 서브 태스크로 분할;
    태스크가 다시 서브태스크로 분할되도록 이 메서드를 재귀적으로 호출;
    모든 서브태스크의 연산이 완료될 때 까지 대기;
    각 서브태스크의 결과 합산;
}
```
- 태스크를 더 분할할 것인지 말 것인지 정해진 기준은 없으나, 경험적으로 얻은 몇 가지 좋은 데이터가 있음
- 분할 후 정복(divide-and-conquer) 알고리즘의 병렬화 버전이다.


## ForkJoinPool
- 일반적으로 애플리케이션은 둘 이상의 `ForkJoinPool`을 사용하지 않음
- SW의 필요한 곳에서 언제든 가져다 쓸 수 있도록 `ForkJoinPool`을 한 번만 인스턴스화 해서 정적 필드에 싱글턴으로 저장함.
- JVM에서 이용할 수 있는 모든 프로세서가 자유롭게 풀에 접근할 수 있다.
  - 더 정확하게는 `Runtime.availableProcessors`의 반환값으로 풀에 사용할 스레드 수를 결정한다.
  - 실제 프로세서 외에도, 하이퍼 스레딩과 관련된 가상 프로세서도 개수에 포함 됨


## 실행
1. `RecursiveTask`를 구현한 객체(`ForkJoinSumCalculator`)를 `ForkJoinPool`로 전달하면, 풀의 스레드가 해당 클래스의 `compute`메서드를 실행하면서 작업을 수행한다.
2. `compute`메서드는 병렬로 실행할 수 있을 만큼 태스크의 크기가 충분히 작아졌는지를 확인한다.
3. 아직 태스크의 크기가 크다고 판단되면 숫자 배열을 반으로 분할해서, 두 개의 새로운 `ForkJoinSumCalculator`로 할당한다.
4. 다시 `ForkJoinPool`이 새로 생성된 `ForkJoinSumCalculator`를 실행한다.
5. 2~4 과정이 재귀적으로 반복되면서, 주어진 조건(예시에서는 항목이 1만개 이하여야 함)을 만족할 때 까지 태스크 분할을 반복한다.
6. 각 서브 태스크들이 순차적으로 처리된다.
7. 포킹 프로세스로 만들어진 이진트리의 태스크를 루트에서 역순으로 방문하여(스택은 LIFO이므로), 각 서브태스크의 부분 결과를 합쳐서 태스크의 최종 결과를 계산한다.



## 포크/조인 프레임워크를 제대로 사용하는 방법
### 효과적으로 사용하는 방법
- `join`메서드를 태스크에 호출하면, 태스크가 생산하는 결과가 준비될 떄 까지 호출자를 블록시킨다.
  - 따라서, 두 서브태스크가 모두 시작된 후에 `join`을 호출해야 한다.
  - 그렇지 않으면 각각의 서브태스크가 다른 태스크가 끝나길 기다리는 일이 발생한다.
  - 결과적으로 순차 알고리즘보다 느리고 복잡해진다.


- `RecursiveTask`내에서는 `ForkJoinPool`의 `invoke`메서드를 사용하지 말아야 한다.
  - `compute`나 `fork`메서드를 직접 호출할 수 있다.
  - 순차 코드에서 병렬 계산을 시작할 때만 `invoke`를 사용한다.


- 서브 태스크에 `fork`메서드를 호출해서 `ForkJoinPool`의 일정을 조절할 수 있다.
  - 왼쪽 작업과 오른쪽 작업 모두에 `fork`메서드를 호출하는 것이 자연스러울 것 같지만, 한쪽에는 `fork` 대신 `compute`를 호출하는 게 효율적이다.
  - 위와 같이 할 경우, 한 태스크는 같은 스레드를 재사용할 수 있으므로, 풀에서 불필요한 태스크를 할당하는 오버헤드를 피할 수 있다.


- `ForkJoin`프레임워크를 이용하는 병렬 계산은 디버깅이 매우 어렵다. (어쩐지.....)
  - 포크/조인 프레임워크에서는 `fork`라고 불리는 다른 스레드에서 `compute`를 호출하기 때문에 스택 트레이스가 도움되지 않는다.


- 멀티코어 + 포크/조인 프레임워크가 순차 처리보다 무조건 빠른 것은 아니다!
  - 병렬 처리로 성능을 개선하려면, 태스크를 여러 독립적인 태스크로 분할할 수 있어야 한다.
  - 각 서브태스크의 실행 시간은, 새로운 태스크를 포킹하는 데 드는 시간보다 길어야 한다.
    - 예 : I/O를 한 서브태스크에 할당하고, 다른 서브태스크에서는 계산을 실행하는 경우, I/O와 계산을 병렬 실행할 수 있다.
  - 순차 버전과 병렬 버전의 성능을 비교할 때는 다른 요소도 고려해야 한다.
    - `JIT`컴파일러에 의해 최적화 되려면, 몇 차례의 "준비 과정(wormed up)" 또는 실행 과정을 고쳐야 한다.
    - 따라서, 여러번 프로그램을 실행한 결과를 측정해야 함
    - 또한, 컴파일러 최적화는 **병렬 버전 보다는 순차 버전에 집중될 수 있다는 사실**도 기억하자.
      - 예를 들어, 순차 버전에서는 죽은 코드를 분석해서 사용되지 않는 계산은 아예 삭제하는 등의 최적화를 달성하기 쉽다.


- 포크/조인 분할 전략에서는 주어진 서브태스크를 더 분할할 것인지 결정할 기준을 정해야 한다.


## 작업 훔치기(work stealing)
- `ForkJoinPool`의 모든 스레드를 거의 공정하게 분할함
- 각 스레드는 자신에게 할당된 태스크를 포함하는 `DoublyLinkedList(이중 연결 리스트)`를 참조하면서, 작업이 끝날 때 마다 큐의 헤드에서 다른 태스크를 가져와서 작업을 처리함
- 아마 이중 연결리스트는 `workQueue`인 것 같다. (`fork`를 호출하면 해당 큐에 작업을 put으로 올리는 것을 확인함)
- 이 때, 한 스레드는 다른 스레드보다 자신에게 할당된 태스크를 더 빨리 처리할 수 있다.
- 즉, 다른 스레드는 바쁘게 일하고 있고, 한 스레드는 할 일이 떨어진 상황임
- 할일이 없어진 스레드는 "유휴 상태"로 바뀌는게 아니고, **다른 스레드 큐의 꼬리에서 작업을 훔쳐온다**
- 모든 태스크가 작업을 끝낼 때 까지, 즉 모든 큐가 빌 때 까지 이 과정을 반복한다.
- 따라서, 태스크의 크기를 작게 나누어야, 작업자 스레드 간의 작업 부하를 비슷한 수준으로 유지할 수 있다.

> 풀에 있는 작업자 스레드의 태스크를 재분배 하고 균형을 맞출 때 **작업 훔치기** 알고리즘을 사용한다.
- 작업자의 큐에 있는 태스크를 두개의 서브 태스크로 분할했을 때, 둘 중 하나의 태스크를 다른 유휴 작업자가 훔쳐갈 수 있다.
- 그리고, 주어진 태스크를 순차 실행할 단계가 될 때 까지 이 과정을 재귀적으로 반복한다.
























