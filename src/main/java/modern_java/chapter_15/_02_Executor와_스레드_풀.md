# Executor와 스레드 풀
## 스레드의 문제 
- 자바 스레드는 직접 운영체제 스레드에 접근한다. 
  - 운영체제 스레드를 만들고 종료하기 위해서는 비싼 비용(페이지 테이블과 관련한 상호작용)을 치러야 함 
  - 운영체제 스레드 숫자는 제한되어있음 -> 초과해 사용할 경우 자바 애플리케이션이 예상치 못한 방식으로 충돌이 날 수 있음 
  - 기존 스레드가 실행되는 상태에서 계속 새로운 스레드를 만드는 상황이 발생하지 않도록 주의해야 함

    
- 운영체제와 자바의 스레드 개수 > 하드웨어 스레드 개수 
  - 일부 운영체제 스레드가 블록되거나, sleep인 상황에서 모든 하드웨어 스레드가 코드를 실행하도록 할당된 상황에 놓을 수 있음 
    - 뭔말인가 했는데.. 아마 운영체제/자바의 스레드 개수가 하드웨어 개수보다 많기 때문에, 운영체제 스레드의 일부가 블록되거나 sleep인 상황이라 하더라도 모든 하드웨어 스레드를 실행하고 있을 수 있다는 말 같다..(쓰고보니 같은말인가?)
  - 인텔 i7-6900K : 각 코어가 여러 하드웨어 스레드를 포함 -> 캐시 미스같은 잠깐의 지연 동안에도 유용한 명령어 수행 가능 
    - 8개의 코어를 가지며, 각 코어는 2개의 대칭 멀티프로세싱(SMP) 하드웨어 스레드를 포함한다. 
    - 즉, 하드웨어 스레드가 총 16개 포함된다. -> 서버에는 프로세서를 여러 개 포함할 수 있어, 보통 하드웨어 스레드 64개를 가질 수 있음. 
    - 하지만, 다양한 기기에서 실행할 수 있는 프로그램에서는 미리 하드웨어 스레드 개수를 추측하지 않는 것이 좋다. (다를 수 있음)
  - 최적의 자바 스레드 개수는 사용할 수 있는 하드웨어의 코어 개수에 따라 달라진다. 


> 비대칭 멀티 프로세싱과 대칭 멀티 프로세싱
> - 비대칭 멀티 프로세싱(AMP)
>   - 프로세서들 간에 주종관계가 있음 
>   - 주인 프로세서가 종 프로세서에 작업을 할당해주고 관리해준다.
>   - 장점 : 자료 공유 필요성 감소 -> 단순화
>   - 단점 : 주인 프로세서가 전체 시스템 성능을 저하시킬 수 있는 병목 지점이 될 수 있다. 이 때, 다른 종(slave) 프로세서들은 주인 프로세서가 작업을 할당해줄 때 까지 기다려야 함
> 
> 
> - 대칭 멀티 프로세싱(SMP) -> 오늘날의 멀티 프로세서!
>   - 주종관계 없이, 모든 프로세서들이 동일한 peer로 동작 
>   - 각 프로세서는 다른 프로세서의 간섭 없이 각자 자신의 작업을 수행함 
>   - N개의 cpu가 있을 경우, 성능을 크게 저하하지 않으면서 N개의 프로세스를 실행 
>   - 프로세스 및 메모리와 같은 자원을 다양한 프로세서간에 동적으로 공유할 수 있고, 프로세서 간 작업 부하 분산을 낮출 수 있음 
>   - 각 프로세서는 스스로 스케줄링한다. 공통의 ready queue를 갖거나, 각자 private ready queue를 가질 수 있음 
>   - SMP 시스템에서 여러 프로세서를 최대한 활용하기 위해 부하를 모든 처리기에 균등 배분하는 것이 중요 



## 스레드 풀, 그리고 스레드 풀이 더 좋은 이유 
### ExecutorService
- 태스크를 제출하고, 나중에 결과를 수집할 수 있는 인터페이스를 제공 
- `newFixedThreadPool`과 같은 팩토리 메서드 중 하나를 이용해 스레드 풀을 만들어 사용할 수 있음 
  - 워커 스레드인 nThread를 포함하는 ExecutorService를 만들고, 이들을 스레드 풀에 저장 
  - 스레드 풀에서 사용하지 않은 스레드로, 제출된 태스크를 먼저 온 순서대로 실행 
  - 태스크 실행 종료 시, 이들 스레드를 스레드 풀로 반환
  - 장점
    - 하드웨어에 맞는 수의 태스크 유지. 
    - 수 천개의 태스크를 스레드 풀에 아무 오버헤드 없이 제출 가능.
    - 큐의 크기 조정, 거부 정책, 태스크 종류에 따른 우선순위 등의 다양한 설정 가능 
  
- 프로그래머가 태스크(Runnable/Callable)를 제공하면 스레드가 이를 실행함 


## 스레드 풀, 그리고 스레드 풀이 나쁜 이유 
- 스레드를 직접 사용하는 것 보다, 대부분 스레드 풀을 이용하는 것이 바람직하다.

### 하지만, 아래의 두 가지 사항을 주의해야 한다.
- k개의 스레드를 가진 스레드 풀은 오직 k만큼의 스레드를 동시 실행할 수 있다.
  - 이 때, 초과로 제출된 태스크는 큐에 저장된다. 이전 태스크 중 하나가 종료되기 전 까지는 스레드에 할당하지 않는다.
  - 이는 불필요하게 많은 스레드를 만드는 일을 피할 수 있으나, 아래와 같은 상황에는 문제가 발생할 수 있다.
    - 스레드가 sleep 상태인 경우
    - `I/O`를 기다리는 경우 -> 태스크가 워커 스레드에 할당된 상태를 유지하지만, 아무 작업도 하지 않는다. 
    - 네트워크 연결을 기다리는 경우 
  - 만약, 위와 같은 상황에서, 처음 제출한 태스크가 "기존에 실행 중이던 태스크가 제출을 기다리는 상황(일반적으로 Future를 사용할 때)"에 놓여있다면 데드락에 걸릴 가능성이 있다.
  - 블록 가능한 태스크는 스레드 풀에 제출하지 말아야 한다. 하지만 이를 항상 지킬 순 없다.


- 중요한 코드를 실행하는 스레드가 죽는 일이 발생하지 않도록, 보통 자바 프로그램은 main이 반환하기 전에 모든 스레드 작업이 끝나길 기다린다.
  - 따라서, 프로그램을 종료하기 전에 모든 스레드 풀을 종료하는 습관을 갖는 것이 중요하다 
    - 풀의 워커 스레드가 만들어진 후, 다른 태스크 제출을 기다리면서 종료되지 않은 상태일 수 있기 때문 
  - 보통 장기간 실행하는 인터넷 서비스를 관리하도록, 오래 실행되는 ExecutorService를 갖는 것은 흔한 일이다.
    - 이런 상황을 다룰 수 있도록 자바는 `Thread.setDeamon`메서드를 제공한다.


## 스레드의 다른 추상화 : 중첩되지 않은 메서드 호출
- 엄격한 포크/조인
  - 태스크나 스레드가 메서드 호출 안에서 시작
  - 해당 메서드 호출이 반환되지 않고 작업이 끝나기를 기다림
  - 즉, 스레드 생성과 `join()`이 한 쌍처럼 중첩된 메서드 호출 내에 추가된다.

- 여유로운 포크/조인 
  - 시작된 태스크를 내부 호출이 아닌, 외부 호출에서 종료하도록 기다림 
  - 이는 일반 호출로 간주할 수 있음 

- 비동기 메서드 : 메서드 호출자에게 기능을 제공하도록, 메서드가 반환된 후에도 만들어진 태스크 실행이 계속되는 메서드 
  - 메서드 호출 
  - 스레드 생성 
  - 스레드가 메서드를 벗어나 계속 실행되는 동시성 형태로 수행 됨 

### 비동기 메서드를 사용할 때 따를 수 있는 위험성
- 스레드 실행은 메서드를 호출한 다음의 코드와 동시에 실행된다. 
  - 데이터 경쟁 문제가 발생하지 않도록 주의해야 한다.
- 기존 실행 중이던 스레드가 종료되지 않은 상황에서, 자바의 `main()`메서드가 반환 후 종료된다면??
  - 애플리케이션을 종료하지 못하고 모든 스레드가 실행을 끝낼 때 까지 기다린다.
    - 잊고서 종료하지 못한 스레드에 의해 애플리케이션이 크래시 될 수 있음
    - 디스크에 쓰기 I/O 작업을 시도하는 일련의 작업을 중단했을 때, 이로 인해 외부 데이터의 일관성이 파괴될 수 있음 
  - 애플리케이션 종료를 방해하는 스레드를 강제 종료(kill)시키고, 애플리케이션을 종료한다
- 이들 문제를 피하기 위해, 애플리케이션을 종료하기 전에 스레드 풀을 포함한 모든 스레드를 종료하자.
  - `setDaemon()`메서드를 통해 스레드를 데몬 스레드와 비데몬 스레드로 구분할 수 있다.
  - 데몬 스레드는 애플리케이션이 종료될 때 강제 종료 -> 데이터 일관성을 파괴하지 않는 동작을 수행할 때 유용함
  - `main()`메서드는 모든 비데몬 스레드가 종료될 때까지 프로그램을 종료하지 않고 기다림 


## 스레드에 무엇을 바라는가?
- 목표 : 모든 하드웨어 스레드 활용 -> 병렬성 장점 극대화하도록 프로그램 구조를 만듬 
  - 즉, 프로그램을 적당히 작은 태스크 단위로 구조화 하는 것이 목표다 (태스크 변환 비용 고려)
  - 