# 동기 API & 비동기 API 
- 별도의 메서드가 상호작용하지 않는다는 사실을 알고 있거나, 상호작용을 신경쓰지 않는다면
  - 각각의 메서드를 별도의 CPU 코어로 실행 -> 시간 단축 
- 명시적 반복 병렬화 수행 -> 스트림을 이용해 내부 반복으로 변경 후 병렬화 수행  

### 동기 API
- 결과가 나올 때 까지 물리적인 반환을 지연시킴. 
- 블록킹 API로도 알려져 있음 (I/O 작업이 가장 흔한 예시)


### 비동기 API
- 블록하지 않는 I/O 구현 (결과를 기다리지 않고 작업 시작. Netty가 대표적인 예시.)
- 자바의 Future를 이용하면 코드가 복잡해지는 문제를 개선할 수 있다.
  - CompletableFuture로 이들을 조합할 수 있게 되면서, 더욱이 기능이 풍부해졌다.
- 발행-구독 프로토콜에 기반한 자바9의 `java.util.concurrent.Flow`


## Future형식 API
큰 프로그램에서는 해당 방식을 사용하지 않는다.
- 병렬 하드웨어로 프로그램 실행 속도를 극대화하려면, 여러 개의 작은, 하지만 합리적인 크기의 태스크로 나누는 것이 좋다. 
- Future 형식의 API는 일회성의 값을 처리하는 데 적합하다.


## 리액티브 형식 API
- 콜백 형식의 프로그래밍을 이용하는 방식.
- 문제점
  - 호출 합계가 정확하지 않을 수 있고, 상황에 따라 먼저 계산된 결과를 출력할 수 있음
  - 출력이 여러번 될 수 있음 
  - `+` 연산자에 제공된 두 개의 피 연산자가 `println`등의 메서드가 호출되기 전에 업데이트 될 수도 있음  
- 해결
  - `if-else`를 이용해 적절한 락을 사용한다.
    - 두 콜백이 모두 호출되었는지 확인한 후 println을 수행하도록 한다.
  - 리액티브 형식의 API는 보통 하나의 결과가 아니라, 일련의 **이벤트에 반응**하도록 설게되었으므로 `Futrure`를 이용하는 것이 더 적절하다.
- 리액티브 형식 API는 자연스럽게 일련의 값을 처리하는 데 적합하다. (나중에 스트림으로 연결)


## sleep과 기타 blocking 동작은 해로운 것으로 간주 
- `sleep()`으로 스레드가 잠들어도, 여전히 시스템 자원을 점유한다. 
  - 스레드 풀에서 `sleep()`을 수행한 태스크는 다른 태스크가 시작되지 못하게 막으므로 자원을 소비한다
    - 운영체제가 이들 태스크를 관리하므로, 일단 스레드로 할당된 태스크는 중지시킬 수 없다 


- 모든 block 동작도 마찬가지다.
  - 다른 태스크가 어떤 동작을 완료하기를 기다리는 동작이다. 
    - Future의 get() 호출
    - 네트워크, DB 서버에서 읽기 작업을 기다리거나, 키보드 입력과 같은 상호작용 대기  


- 태스크에서 기다리는 일을 만들지 않거나, 코드에서 예외를 일으키는 방법으로 처리하라  

### Thread.sleep() : 자는 동안에도 자원 점유 
```java
work1();
Thread.sleep(10000);
System.out.println("해당 라인도 10초 후에 실행된다. work2()만 단독적으로 10초 후에 실행할 수 없다.");
work2();
```
1. 코드가 스레드 풀 큐에 추가되고, 나중에 차례가 되면 실행한다.
2. 하지만, 코드가 실행되면 워커 스레드를 점유한 상태에서 아무것도 하지 않고 10초를 잔다. 
3. 그리고 꺠어난 후에 다음 코드를 실행한다.
4. 작업을 종료하고 워커 스레드를 해제한다.


### scheduled : 자원을 점유하지 않으며, 다른 작업이 실행될 수 있음 
```java
System.out.println("---");
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);

work1();
scheduledExecutorService.schedule(
_03_Example3::work2, 10,
TimeUnit.SECONDS);  // work1 이 끝난 후, 10초 뒤에 work2를 개별 태스크로 스케줄링

System.out.println("하지만 해당 라인은 잠들지 않는다. work2()만 단독적으로 잠들었다!");

scheduledExecutorService.shutdown();
```
1. work1()을 실행 후 종료 
2. work2()가 10초 뒤에 실행될 수 있도록 큐에 추가 
3. 나머지 작업 수행 


- 태스크를 블록하기 보다는, 다음 작업을 태스크로 제출하고, 현재 태스크는 종료하는 것이 바람직하다.  
- 가능하다면 I/O 작업에도 해당 원칙을 적용해라.
  - 읽기 작업을 기다리기 보다는
  - 블록하지 않는 "읽기 시작" 메서드를 호출하고, 읽기 작업이 끝나면 이를 처리할 다음 태스크를 런타임 라이브러리에 스케줄하도록 요청하고 종료한다.


## 현실성 확인 
- 현실적으로는 "모든 것은 비동기"라는 설계 원칙을 어겨야 한다.


## 비동기 API에서의 예외 처리 
- Future, 리액티브 형식의 비동기 API에서 호출된 메서드의 실제 바디는 **별도의 스레드에서 호출**된다.
  - 때문에, 이 때 발생하는 에러는 이미 호출자의 실행 범위와는 상관 없는 상황이 되어버린다. 
  - 예상치 못한 일이 발생했을 때, 예외를 발생시켜 다른 동작이 실행되어야 하는데, 이는 어떻게 할 수 있을까?

### CompletableFuture 
- 런타임 get() 메서드에 예외를 처리할 수 있는 기능을 제공한다
  - 또한, 예외에서 회복할 수 있도록 exceptionally()와 같은 메서드도 제공한다.

### 리액티브 비동기 API에서의 예외 
- 예외가 발생했을 때 실행될 추가 콜백을 제공해야 한다.
```java
void f(int x, Consumer<Integer> dealWithResult, Consumer<Throwable> dealWithException);

// f의 body는 다음을 수행할 수 있다.
dealWithException(e);
```

- 콜백이 여러개인 경우 따로 제공하기 보다는 한 객체로 메서드를 감싸서 제공해라.
```java
// java9 플로 API의 Subscriber<T> 클래스 
void onComplete();
void onError(Throwable throwable);
void onNext(T item);

// f에 적용한다면 아래와 같이 변경 
void f(int x, Subscriber<Integer> s);

// f의 body는 다음을 수행할 수 있다.
s.onError(t);
```

> 잠깐 나온 키워드
> - 이벤트(메시지)
> - 채널 프로토콜 : 이벤트의 순서 


















